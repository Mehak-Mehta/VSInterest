{"version":3,"sources":["VirtualList.svelte","VirtualList.css"],"names":[],"mappings":"AA2IC,4CAA8B,iBACX,CAClB,eAAgB,CAChB,gCAAgC,CAChC,aAAc,CACd,mFACsD,aACxC,CACd,uCACwB,eACR;ACpJlB,8hOAA8hO","file":"VirtualList.css","sourcesContent":["<script>\r\n\timport { onMount, tick } from 'svelte';\r\n\t// props\r\n\texport let items;\r\n\texport let height = '100%';\r\n\texport let itemHeight = undefined;\r\n\tlet foo;\r\n\t// read-only, but visible to consumers via bind:start\r\n\texport let start = 0;\r\n\texport let end = 0;\r\n\t// local state\r\n\tlet height_map = [];\r\n\tlet rows;\r\n\tlet viewport;\r\n\tlet contents;\r\n\tlet viewport_height = 0;\r\n\tlet visible;\r\n\tlet mounted;\r\n\tlet top = 0;\r\n\tlet bottom = 0;\r\n\tlet average_height;\r\n\r\n\t$: visible = items.slice(start, end).map((data, i) => {\r\n\t\treturn { index: i + start, data };\r\n\t});\r\n\r\n\t// whenever `items` changes, invalidate the current heightmap\r\n\t$: if (mounted && (viewport_height || true) && (itemHeight || true)) refresh();\r\n\r\n  $: if (mounted && items) refreshItems()\r\n\r\n  let itemLength\r\n  let oldItemsLength = items.length\r\n  $: itemLength = items.length\r\n\r\n  async function refreshItems() {\r\n    let itemsLength = items.length\r\n\t\trows = contents.getElementsByTagName('svelte-virtual-list-row');\r\n    top = 0\r\n    bottom = 0\r\n    height_map = []\r\n\r\n    if (itemsLength == 0) {\r\n      start = 0\r\n      end = 0\r\n      return\r\n    }\r\n    if (start > items.length - 1) {\r\n      start = items.length - 1\r\n      end = items.length - 1\r\n    }\r\n    refresh()\r\n    handle_scroll()\r\n  }\r\n\r\n\tasync function refresh() {\r\n\r\n\t\tconst { scrollTop } = viewport;\r\n\r\n    // if items has changed, we have to check to see if start and end are still in range\r\n\r\n\t\tawait tick(); // wait until the DOM is up to date\r\n\t\tlet content_height = top - scrollTop;\r\n\r\n\t\tlet i = start;\r\n\r\n\t\twhile (content_height < viewport_height && i < items.length) {\r\n\t\t\tlet row = rows[i - start];\r\n\t\t\tif (!row) {\r\n\t\t\t\tend = i + 1;\r\n\t\t\t\tawait tick(); // render the newly visible row\r\n\t\t\t\trow = rows[i - start];\r\n\t\t\t}\r\n\t\t\tconst row_height = height_map[i] = itemHeight || row.offsetHeight;\r\n\t\t\tcontent_height += row_height;\r\n\t\t\ti += 1;\r\n\t\t}\r\n\r\n\t\tend = i;\r\n\t\tconst remaining = items.length - end;\r\n\t\taverage_height = (top + content_height) / end;\r\n\t\tbottom = remaining * average_height;\r\n\t\theight_map.length = items.length;\r\n\t}\r\n\r\n\tasync function handle_scroll() {\r\n\t\tconst { scrollTop } = viewport;\r\n\t\tconst old_start = start;\r\n\t\tfor (let v = 0; v < rows.length; v += 1) {\r\n\t\t\theight_map[start + v] = itemHeight || rows[v].offsetHeight;\r\n\t\t}\r\n\t\tlet i = 0;\r\n\t\tlet y = 0;\r\n\t\twhile (i < items.length) {\r\n\t\t\tconst row_height = height_map[i] || average_height;\r\n\t\t\tif (y + row_height > scrollTop) {\r\n\t\t\t\tstart = i;\r\n\t\t\t\ttop = y;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\ty += row_height;\r\n\t\t\ti += 1;\r\n\t\t}\r\n\t\twhile (i < items.length) {\r\n\t\t\ty += height_map[i] || average_height;\r\n\t\t\ti += 1;\r\n\t\t\tif (y > scrollTop + viewport_height) break;\r\n\t\t}\r\n\t\tend = i;\r\n\t\tconst remaining = items.length - end;\r\n\t\taverage_height = y / end;\r\n\t\twhile (i < items.length) height_map[i++] = average_height;\r\n\t\tbottom = remaining * average_height;\r\n\t\t// prevent jumping if we scrolled up into unknown territory\r\n\t\tif (start < old_start) {\r\n\t\t\tawait tick();\r\n\t\t\tlet expected_height = 0;\r\n\t\t\tlet actual_height = 0;\r\n\t\t\tfor (let i = start; i < old_start; i +=1) {\r\n\t\t\t\tif (rows[i - start]) {\r\n\t\t\t\t\texpected_height += height_map[i];\r\n\t\t\t\t\tactual_height += itemHeight || rows[i - start].offsetHeight;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tconst d = actual_height - expected_height;\r\n\t\t\tviewport.scrollTo(0, scrollTop + d);\r\n\t\t}\r\n\t\t// TODO if we overestimated the space these\r\n\t\t// rows would occupy we may need to add some\r\n\t\t// more. maybe we can just call handle_scroll again?\r\n\t}\r\n\t// trigger initial refresh\r\n\tonMount(() => {\r\n\t\trows = contents.getElementsByTagName('svelte-virtual-list-row');\r\n\t\tmounted = true;\r\n\t});\r\n</script>\r\n\r\n<style>\r\n\tsvelte-virtual-list-viewport {\r\n\t\tposition: relative;\r\n\t\toverflow-y: auto;\r\n\t\t-webkit-overflow-scrolling:touch;\r\n\t\tdisplay: block;\r\n\t}\r\n\tsvelte-virtual-list-contents, svelte-virtual-list-row {\r\n\t\tdisplay: block;\r\n\t}\r\n\tsvelte-virtual-list-row {\r\n\t\toverflow: hidden;\r\n\t}\r\n</style>\r\n\r\n<svelte-virtual-list-viewport\r\n\tbind:this={viewport}\r\n\tbind:offsetHeight={viewport_height}\r\n\ton:scroll={handle_scroll}\r\n\tstyle=\"height: {height};\"\r\n>\r\n\t<svelte-virtual-list-contents\r\n\t\tbind:this={contents}\r\n\t\tstyle=\"padding-top: {top}px; padding-bottom: {bottom}px;\"\r\n\t>\r\n\t\t{#each visible as row (row.index)}\r\n\t\t\t<svelte-virtual-list-row>\r\n\t\t\t\t<slot item={row.data}>Missing template</slot>\r\n\t\t\t</svelte-virtual-list-row>\r\n\t\t{/each}\r\n\t</svelte-virtual-list-contents>\r\n</svelte-virtual-list-viewport>\r\n","svelte-virtual-list-viewport.svelte-1kbuqay{position:relative;overflow-y:auto;-webkit-overflow-scrolling:touch;display:block}svelte-virtual-list-contents.svelte-1kbuqay,svelte-virtual-list-row.svelte-1kbuqay{display:block}svelte-virtual-list-row.svelte-1kbuqay{overflow:hidden}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVmlydHVhbExpc3Quc3ZlbHRlIiwic291cmNlcyI6WyJWaXJ0dWFsTGlzdC5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdD5cclxuXHRpbXBvcnQgeyBvbk1vdW50LCB0aWNrIH0gZnJvbSAnc3ZlbHRlJztcclxuXHQvLyBwcm9wc1xyXG5cdGV4cG9ydCBsZXQgaXRlbXM7XHJcblx0ZXhwb3J0IGxldCBoZWlnaHQgPSAnMTAwJSc7XHJcblx0ZXhwb3J0IGxldCBpdGVtSGVpZ2h0ID0gdW5kZWZpbmVkO1xyXG5cdGxldCBmb287XHJcblx0Ly8gcmVhZC1vbmx5LCBidXQgdmlzaWJsZSB0byBjb25zdW1lcnMgdmlhIGJpbmQ6c3RhcnRcclxuXHRleHBvcnQgbGV0IHN0YXJ0ID0gMDtcclxuXHRleHBvcnQgbGV0IGVuZCA9IDA7XHJcblx0Ly8gbG9jYWwgc3RhdGVcclxuXHRsZXQgaGVpZ2h0X21hcCA9IFtdO1xyXG5cdGxldCByb3dzO1xyXG5cdGxldCB2aWV3cG9ydDtcclxuXHRsZXQgY29udGVudHM7XHJcblx0bGV0IHZpZXdwb3J0X2hlaWdodCA9IDA7XHJcblx0bGV0IHZpc2libGU7XHJcblx0bGV0IG1vdW50ZWQ7XHJcblx0bGV0IHRvcCA9IDA7XHJcblx0bGV0IGJvdHRvbSA9IDA7XHJcblx0bGV0IGF2ZXJhZ2VfaGVpZ2h0O1xyXG5cclxuXHQkOiB2aXNpYmxlID0gaXRlbXMuc2xpY2Uoc3RhcnQsIGVuZCkubWFwKChkYXRhLCBpKSA9PiB7XHJcblx0XHRyZXR1cm4geyBpbmRleDogaSArIHN0YXJ0LCBkYXRhIH07XHJcblx0fSk7XHJcblxyXG5cdC8vIHdoZW5ldmVyIGBpdGVtc2AgY2hhbmdlcywgaW52YWxpZGF0ZSB0aGUgY3VycmVudCBoZWlnaHRtYXBcclxuXHQkOiBpZiAobW91bnRlZCAmJiAodmlld3BvcnRfaGVpZ2h0IHx8IHRydWUpICYmIChpdGVtSGVpZ2h0IHx8IHRydWUpKSByZWZyZXNoKCk7XHJcblxyXG4gICQ6IGlmIChtb3VudGVkICYmIGl0ZW1zKSByZWZyZXNoSXRlbXMoKVxyXG5cclxuICBsZXQgaXRlbUxlbmd0aFxyXG4gIGxldCBvbGRJdGVtc0xlbmd0aCA9IGl0ZW1zLmxlbmd0aFxyXG4gICQ6IGl0ZW1MZW5ndGggPSBpdGVtcy5sZW5ndGhcclxuXHJcbiAgYXN5bmMgZnVuY3Rpb24gcmVmcmVzaEl0ZW1zKCkge1xyXG4gICAgbGV0IGl0ZW1zTGVuZ3RoID0gaXRlbXMubGVuZ3RoXHJcblx0XHRyb3dzID0gY29udGVudHMuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3N2ZWx0ZS12aXJ0dWFsLWxpc3Qtcm93Jyk7XHJcbiAgICB0b3AgPSAwXHJcbiAgICBib3R0b20gPSAwXHJcbiAgICBoZWlnaHRfbWFwID0gW11cclxuXHJcbiAgICBpZiAoaXRlbXNMZW5ndGggPT0gMCkge1xyXG4gICAgICBzdGFydCA9IDBcclxuICAgICAgZW5kID0gMFxyXG4gICAgICByZXR1cm5cclxuICAgIH1cclxuICAgIGlmIChzdGFydCA+IGl0ZW1zLmxlbmd0aCAtIDEpIHtcclxuICAgICAgc3RhcnQgPSBpdGVtcy5sZW5ndGggLSAxXHJcbiAgICAgIGVuZCA9IGl0ZW1zLmxlbmd0aCAtIDFcclxuICAgIH1cclxuICAgIHJlZnJlc2goKVxyXG4gICAgaGFuZGxlX3Njcm9sbCgpXHJcbiAgfVxyXG5cclxuXHRhc3luYyBmdW5jdGlvbiByZWZyZXNoKCkge1xyXG5cclxuXHRcdGNvbnN0IHsgc2Nyb2xsVG9wIH0gPSB2aWV3cG9ydDtcclxuXHJcbiAgICAvLyBpZiBpdGVtcyBoYXMgY2hhbmdlZCwgd2UgaGF2ZSB0byBjaGVjayB0byBzZWUgaWYgc3RhcnQgYW5kIGVuZCBhcmUgc3RpbGwgaW4gcmFuZ2VcclxuXHJcblx0XHRhd2FpdCB0aWNrKCk7IC8vIHdhaXQgdW50aWwgdGhlIERPTSBpcyB1cCB0byBkYXRlXHJcblx0XHRsZXQgY29udGVudF9oZWlnaHQgPSB0b3AgLSBzY3JvbGxUb3A7XHJcblxyXG5cdFx0bGV0IGkgPSBzdGFydDtcclxuXHJcblx0XHR3aGlsZSAoY29udGVudF9oZWlnaHQgPCB2aWV3cG9ydF9oZWlnaHQgJiYgaSA8IGl0ZW1zLmxlbmd0aCkge1xyXG5cdFx0XHRsZXQgcm93ID0gcm93c1tpIC0gc3RhcnRdO1xyXG5cdFx0XHRpZiAoIXJvdykge1xyXG5cdFx0XHRcdGVuZCA9IGkgKyAxO1xyXG5cdFx0XHRcdGF3YWl0IHRpY2soKTsgLy8gcmVuZGVyIHRoZSBuZXdseSB2aXNpYmxlIHJvd1xyXG5cdFx0XHRcdHJvdyA9IHJvd3NbaSAtIHN0YXJ0XTtcclxuXHRcdFx0fVxyXG5cdFx0XHRjb25zdCByb3dfaGVpZ2h0ID0gaGVpZ2h0X21hcFtpXSA9IGl0ZW1IZWlnaHQgfHwgcm93Lm9mZnNldEhlaWdodDtcclxuXHRcdFx0Y29udGVudF9oZWlnaHQgKz0gcm93X2hlaWdodDtcclxuXHRcdFx0aSArPSAxO1xyXG5cdFx0fVxyXG5cclxuXHRcdGVuZCA9IGk7XHJcblx0XHRjb25zdCByZW1haW5pbmcgPSBpdGVtcy5sZW5ndGggLSBlbmQ7XHJcblx0XHRhdmVyYWdlX2hlaWdodCA9ICh0b3AgKyBjb250ZW50X2hlaWdodCkgLyBlbmQ7XHJcblx0XHRib3R0b20gPSByZW1haW5pbmcgKiBhdmVyYWdlX2hlaWdodDtcclxuXHRcdGhlaWdodF9tYXAubGVuZ3RoID0gaXRlbXMubGVuZ3RoO1xyXG5cdH1cclxuXHJcblx0YXN5bmMgZnVuY3Rpb24gaGFuZGxlX3Njcm9sbCgpIHtcclxuXHRcdGNvbnN0IHsgc2Nyb2xsVG9wIH0gPSB2aWV3cG9ydDtcclxuXHRcdGNvbnN0IG9sZF9zdGFydCA9IHN0YXJ0O1xyXG5cdFx0Zm9yIChsZXQgdiA9IDA7IHYgPCByb3dzLmxlbmd0aDsgdiArPSAxKSB7XHJcblx0XHRcdGhlaWdodF9tYXBbc3RhcnQgKyB2XSA9IGl0ZW1IZWlnaHQgfHwgcm93c1t2XS5vZmZzZXRIZWlnaHQ7XHJcblx0XHR9XHJcblx0XHRsZXQgaSA9IDA7XHJcblx0XHRsZXQgeSA9IDA7XHJcblx0XHR3aGlsZSAoaSA8IGl0ZW1zLmxlbmd0aCkge1xyXG5cdFx0XHRjb25zdCByb3dfaGVpZ2h0ID0gaGVpZ2h0X21hcFtpXSB8fCBhdmVyYWdlX2hlaWdodDtcclxuXHRcdFx0aWYgKHkgKyByb3dfaGVpZ2h0ID4gc2Nyb2xsVG9wKSB7XHJcblx0XHRcdFx0c3RhcnQgPSBpO1xyXG5cdFx0XHRcdHRvcCA9IHk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdFx0eSArPSByb3dfaGVpZ2h0O1xyXG5cdFx0XHRpICs9IDE7XHJcblx0XHR9XHJcblx0XHR3aGlsZSAoaSA8IGl0ZW1zLmxlbmd0aCkge1xyXG5cdFx0XHR5ICs9IGhlaWdodF9tYXBbaV0gfHwgYXZlcmFnZV9oZWlnaHQ7XHJcblx0XHRcdGkgKz0gMTtcclxuXHRcdFx0aWYgKHkgPiBzY3JvbGxUb3AgKyB2aWV3cG9ydF9oZWlnaHQpIGJyZWFrO1xyXG5cdFx0fVxyXG5cdFx0ZW5kID0gaTtcclxuXHRcdGNvbnN0IHJlbWFpbmluZyA9IGl0ZW1zLmxlbmd0aCAtIGVuZDtcclxuXHRcdGF2ZXJhZ2VfaGVpZ2h0ID0geSAvIGVuZDtcclxuXHRcdHdoaWxlIChpIDwgaXRlbXMubGVuZ3RoKSBoZWlnaHRfbWFwW2krK10gPSBhdmVyYWdlX2hlaWdodDtcclxuXHRcdGJvdHRvbSA9IHJlbWFpbmluZyAqIGF2ZXJhZ2VfaGVpZ2h0O1xyXG5cdFx0Ly8gcHJldmVudCBqdW1waW5nIGlmIHdlIHNjcm9sbGVkIHVwIGludG8gdW5rbm93biB0ZXJyaXRvcnlcclxuXHRcdGlmIChzdGFydCA8IG9sZF9zdGFydCkge1xyXG5cdFx0XHRhd2FpdCB0aWNrKCk7XHJcblx0XHRcdGxldCBleHBlY3RlZF9oZWlnaHQgPSAwO1xyXG5cdFx0XHRsZXQgYWN0dWFsX2hlaWdodCA9IDA7XHJcblx0XHRcdGZvciAobGV0IGkgPSBzdGFydDsgaSA8IG9sZF9zdGFydDsgaSArPTEpIHtcclxuXHRcdFx0XHRpZiAocm93c1tpIC0gc3RhcnRdKSB7XHJcblx0XHRcdFx0XHRleHBlY3RlZF9oZWlnaHQgKz0gaGVpZ2h0X21hcFtpXTtcclxuXHRcdFx0XHRcdGFjdHVhbF9oZWlnaHQgKz0gaXRlbUhlaWdodCB8fCByb3dzW2kgLSBzdGFydF0ub2Zmc2V0SGVpZ2h0O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRjb25zdCBkID0gYWN0dWFsX2hlaWdodCAtIGV4cGVjdGVkX2hlaWdodDtcclxuXHRcdFx0dmlld3BvcnQuc2Nyb2xsVG8oMCwgc2Nyb2xsVG9wICsgZCk7XHJcblx0XHR9XHJcblx0XHQvLyBUT0RPIGlmIHdlIG92ZXJlc3RpbWF0ZWQgdGhlIHNwYWNlIHRoZXNlXHJcblx0XHQvLyByb3dzIHdvdWxkIG9jY3VweSB3ZSBtYXkgbmVlZCB0byBhZGQgc29tZVxyXG5cdFx0Ly8gbW9yZS4gbWF5YmUgd2UgY2FuIGp1c3QgY2FsbCBoYW5kbGVfc2Nyb2xsIGFnYWluP1xyXG5cdH1cclxuXHQvLyB0cmlnZ2VyIGluaXRpYWwgcmVmcmVzaFxyXG5cdG9uTW91bnQoKCkgPT4ge1xyXG5cdFx0cm93cyA9IGNvbnRlbnRzLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzdmVsdGUtdmlydHVhbC1saXN0LXJvdycpO1xyXG5cdFx0bW91bnRlZCA9IHRydWU7XHJcblx0fSk7XHJcbjwvc2NyaXB0PlxyXG5cclxuPHN0eWxlPlxyXG5cdHN2ZWx0ZS12aXJ0dWFsLWxpc3Qtdmlld3BvcnQge1xyXG5cdFx0cG9zaXRpb246IHJlbGF0aXZlO1xyXG5cdFx0b3ZlcmZsb3cteTogYXV0bztcclxuXHRcdC13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOnRvdWNoO1xyXG5cdFx0ZGlzcGxheTogYmxvY2s7XHJcblx0fVxyXG5cdHN2ZWx0ZS12aXJ0dWFsLWxpc3QtY29udGVudHMsIHN2ZWx0ZS12aXJ0dWFsLWxpc3Qtcm93IHtcclxuXHRcdGRpc3BsYXk6IGJsb2NrO1xyXG5cdH1cclxuXHRzdmVsdGUtdmlydHVhbC1saXN0LXJvdyB7XHJcblx0XHRvdmVyZmxvdzogaGlkZGVuO1xyXG5cdH1cclxuPC9zdHlsZT5cclxuXHJcbjxzdmVsdGUtdmlydHVhbC1saXN0LXZpZXdwb3J0XHJcblx0YmluZDp0aGlzPXt2aWV3cG9ydH1cclxuXHRiaW5kOm9mZnNldEhlaWdodD17dmlld3BvcnRfaGVpZ2h0fVxyXG5cdG9uOnNjcm9sbD17aGFuZGxlX3Njcm9sbH1cclxuXHRzdHlsZT1cImhlaWdodDoge2hlaWdodH07XCJcclxuPlxyXG5cdDxzdmVsdGUtdmlydHVhbC1saXN0LWNvbnRlbnRzXHJcblx0XHRiaW5kOnRoaXM9e2NvbnRlbnRzfVxyXG5cdFx0c3R5bGU9XCJwYWRkaW5nLXRvcDoge3RvcH1weDsgcGFkZGluZy1ib3R0b206IHtib3R0b219cHg7XCJcclxuXHQ+XHJcblx0XHR7I2VhY2ggdmlzaWJsZSBhcyByb3cgKHJvdy5pbmRleCl9XHJcblx0XHRcdDxzdmVsdGUtdmlydHVhbC1saXN0LXJvdz5cclxuXHRcdFx0XHQ8c2xvdCBpdGVtPXtyb3cuZGF0YX0+TWlzc2luZyB0ZW1wbGF0ZTwvc2xvdD5cclxuXHRcdFx0PC9zdmVsdGUtdmlydHVhbC1saXN0LXJvdz5cclxuXHRcdHsvZWFjaH1cclxuXHQ8L3N2ZWx0ZS12aXJ0dWFsLWxpc3QtY29udGVudHM+XHJcbjwvc3ZlbHRlLXZpcnR1YWwtbGlzdC12aWV3cG9ydD5cclxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQTJJQyw0QkFBNEIsZUFBQyxDQUFDLEFBQzdCLFFBQVEsQ0FBRSxRQUFRLENBQ2xCLFVBQVUsQ0FBRSxJQUFJLENBQ2hCLDJCQUEyQixLQUFLLENBQ2hDLE9BQU8sQ0FBRSxLQUFLLEFBQ2YsQ0FBQyxBQUNELDJDQUE0QixDQUFFLHVCQUF1QixlQUFDLENBQUMsQUFDdEQsT0FBTyxDQUFFLEtBQUssQUFDZixDQUFDLEFBQ0QsdUJBQXVCLGVBQUMsQ0FBQyxBQUN4QixRQUFRLENBQUUsTUFBTSxBQUNqQixDQUFDIn0= */"]}